<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>iMessage-style Chat</title>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <style>
        /* --- Fonts --- */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&display=swap');

        :root {
            --bg: #f3f3f7;
            --card: rgba(255,255,255,0.7);
            --muted: #8e8e93;
            --sent-grad: linear-gradient(135deg,#007aff,#34c759 60%);
            --sent-text: #fff;
            --recv-bg: #e5e5ea;
            --recv-text: #000;
            --header-blur: rgba(255,255,255,0.6);
            --input-bg: rgba(255,255,255,0.9);
            --shadow: 0 8px 24px rgba(23,23,23,0.12);
            font-synthesis: none;
        }

        /* Dark mode variables */
        @media (prefers-color-scheme: dark) {
            :root {
                --bg: linear-gradient(180deg,#0b1220,#08101a);
                --card: rgba(12,12,14,0.6);
                --muted: #9aa3b2;
                --sent-grad: linear-gradient(135deg,#007aff,#00a3ff 60%);
                --sent-text: #ffffff;
                --recv-bg: rgba(255,255,255,0.06);
                --recv-text: #e6eef8;
                --header-blur: rgba(6,6,8,0.6);
                --input-bg: rgba(10,10,12,0.45);
                --shadow: 0 12px 36px rgba(2,6,23,0.6);
            }
        }

        /* Base layout */
        html,body{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;}
        body{
            background: var(--bg);
            display:flex;
            align-items:center;
            justify-content:center;
            padding:20px;
        }

        .chat-frame{
            width:100%;
            max-width:420px;
            height:92vh;
            border-radius:22px;
            overflow:hidden;
            display:flex;
            flex-direction:column;
            background: linear-gradient(180deg, rgba(255,255,255,0.35), rgba(255,255,255,0.18));
            box-shadow: var(--shadow);
            border: 1px solid rgba(255,255,255,0.06);
            backdrop-filter: blur(10px);
        }

        /* Header (iMessage style) */
        .chat-header{
            display:flex;
            align-items:center;
            gap:12px;
            padding:12px 16px;
            background: var(--header-blur);
            backdrop-filter: blur(14px);
            border-bottom: 1px solid rgba(0,0,0,0.06);
            flex-shrink:0;
        }
        .avatar{
            width:44px;height:44px;border-radius:50%;display:flex;align-items:center;justify-content:center;color:#fff;font-weight:700;
            background: linear-gradient(135deg,#cfcfcf,#bdbdbd);
            flex-shrink:0;
            font-size:18px;
        }
        .title-block{display:flex;flex-direction:column;line-height:1;}
        .title{font-weight:700;}
        .subtitle{font-size:12px;color:var(--muted);}

        /* Messages area */
        .messages{
            flex:1;
            padding:16px;
            display:flex;
            flex-direction:column;
            gap:10px;
            overflow-y:auto;
            -webkit-overflow-scrolling:touch;
            background: linear-gradient(180deg, transparent, rgba(0,0,0,0.02));
        }

        .message-row{display:flex;flex-direction:column;max-width:80%; animation: fadeUp 360ms cubic-bezier(.2,.9,.2,1); }
        @keyframes fadeUp { from { transform: translateY(8px); opacity:0 } to { transform: translateY(0); opacity:1 } }

        .message-row.sent{align-self:flex-end; align-items:flex-end;}
        .message-row.received{align-self:flex-start; align-items:flex-start;}

        .bubble{
            padding:10px 14px;border-radius:18px;line-height:1.3;font-size:15px;box-shadow: 0 2px 8px rgba(0,0,0,0.04);
            max-width:100%;
            display:inline-block;
        }

        .bubble.sent{
            background: var(--sent-grad);
            color: var(--sent-text);
            border-bottom-right-radius:4px;
            border-bottom-left-radius:18px;
        }
        .bubble.received{
            background: var(--recv-bg);
            color: var(--recv-text);
            border-bottom-left-radius:4px;
            border-bottom-right-radius:18px;
        }

        .meta{font-size:11px;color:var(--muted);margin-bottom:4px;}

        .bubble img{max-width:320px;border-radius:14px;display:block;}
        .bubble audio{width:100%;margin-top:4px;}

        /* typing indicator */
        .typing{height:28px;padding-left:10px;color:var(--muted);display:flex;align-items:center;}
        .dots{display:inline-flex;gap:6px;align-items:center;padding:6px 10px;border-radius:16px;background:var(--recv-bg);}
        .dot{width:7px;height:7px;border-radius:50%;background:var(--muted);transform:scale(0.6);animation: bounce 1s infinite ease-in-out;}
        .dot:nth-child(2){animation-delay:0.12s}
        .dot:nth-child(3){animation-delay:0.24s}
        @keyframes bounce{0%,80%,100%{transform:scale(.6)}40%{transform:scale(1)}}

        /* Input area */
        .composer{
            padding:10px 12px;
            display:flex;
            gap:8px;
            align-items:center;
            background: var(--header-blur);
            border-top:1px solid rgba(0,0,0,0.06);
            flex-shrink:0;
        }
        .input{
            flex:1;
            display:flex;
            align-items:center;
            gap:8px;
            padding:8px 10px;
            background:var(--input-bg);
            border-radius:999px;
            border:1px solid rgba(0,0,0,0.06);
        }
        .input input[type="text"]{
            border:none;outline:none;background:transparent;font-size:15px;color:inherit;width:100%;
        }
        .icon-btn{border:none;background:transparent;padding:6px;cursor:pointer;display:flex;align-items:center;}
        .send-btn{
            background:transparent;border:none;color:var(--sent-grad);font-weight:700;padding:8px 12px;border-radius:12px;cursor:pointer;
        }

        /* small helpers */
        .muted{color:var(--muted);font-size:13px}
        .sending{opacity:0.65;transform:translateY(4px);filter:grayscale(.02) brightness(.98) }

        /* responsive tweaks */
        @media (max-width:420px){
            .chat-frame{height:100vh;border-radius:0;max-width:100%;}
            .messages{padding:12px;}
        }
    </style>
</head>
<body>
    <div class="chat-frame" role="application">
        <!-- Username / Join UI (overlay when no username) -->
        <div id="join-screen" style="position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:transparent;z-index:40;">
            <div style="width:94%;max-width:360px;background:var(--card);padding:18px;border-radius:14px;box-shadow:var(--shadow);text-align:center;">
                <h2 style="margin:0 0 6px 0">Welcome to Chat</h2>
                <p style="margin:0 0 14px;color:var(--muted)">Pick a display name to join the public chat.</p>
                <form id="join-form" style="display:flex;gap:8px;justify-content:center;">
                    <input id="username" type="text" placeholder="Your name" required style="padding:10px 12px;border-radius:10px;border:1px solid rgba(0,0,0,0.06);min-width:0;flex:1;font-size:15px">
                    <button type="submit" style="padding:10px 12px;border-radius:10px;border:none;background:linear-gradient(135deg,#007aff,#00c6ff);color:white;font-weight:700;cursor:pointer">Join</button>
                </form>
                <p id="join-error" class="muted" style="height:18px;margin-top:10px"></p>
            </div>
        </div>

        <header class="chat-header">
            <div class="avatar" id="header-avatar">P</div>
            <div class="title-block">
                <div class="title" id="header-title">Public Chat</div>
                <div class="subtitle" id="header-sub">iMessage-style • Real-time</div>
            </div>
        </header>

        <main class="messages" id="messages" aria-live="polite"></main>

        <div id="typing-area" class="typing" style="display:none">
            <div class="dots"><div class="dot"></div><div class="dot"></div><div class="dot"></div></div>
            <div style="margin-left:8px;color:var(--muted);font-size:13px" id="typing-text"></div>
        </div>

        <div class="composer">
            <div class="input" role="group" aria-label="Message composer">
                <button id="attach-btn" class="icon-btn" title="Attach image">
                    <!-- simple paperclip icon -->
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none"><path d="M21 13v6a3 3 0 0 1-3 3H6a4 4 0 0 1-4-4V7a3 3 0 0 1 3-3h11" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg>
                </button>
                <div style="flex:1;display:flex;align-items:center;">
                    <input id="message-input" type="text" placeholder="iMessage" autocomplete="off" />
                </div>
                <button id="send-btn" class="send-btn" title="Send">Send</button>
            </div>
            <input id="file-input" type="file" accept="image/*" style="display:none" />
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const joinScreen = document.getElementById('join-screen');
    const joinForm = document.getElementById('join-form');
    const usernameInput = document.getElementById('username');
    const joinError = document.getElementById('join-error');

    const headerAvatar = document.getElementById('header-avatar');
    const headerTitle = document.getElementById('header-title');
    const messagesEl = document.getElementById('messages');
    const messageInput = document.getElementById('message-input');
    const sendBtn = document.getElementById('send-btn');
    const attachBtn = document.getElementById('attach-btn');
    const fileInput = document.getElementById('file-input');
    const typingArea = document.getElementById('typing-area');
    const typingText = document.getElementById('typing-text');

    let ws = null;
    let currentUser = localStorage.getItem('chat_username') || null;
    let typingTimeout = null;
    const currentlyTyping = new Set();

    // Helper: scroll to bottom
    function scrollBottom(smooth = true){
        if(!messagesEl) return;
        if(smooth) messagesEl.lastElementChild?.scrollIntoView({behavior:'smooth', block:'end'});
        else messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    // create message DOM node
    function createMessageNode(msg, opts = {}) {
        // opts: { temp: boolean, sending: boolean }
        const row = document.createElement('div');
        row.className = 'message-row ' + (msg.username === currentUser ? 'sent' : 'received');
        if(opts.sending) row.classList.add('sending');
        if(opts.temp) {
            row.dataset.tempUsername = msg.username || '';
            row.dataset.tempContent = msg.content || '';
        }
        // optional username label for received
        if(msg.username !== currentUser){
            const meta = document.createElement('div');
            meta.className = 'meta';
            meta.textContent = msg.username;
            row.appendChild(meta);
        }
        const bubble = document.createElement('div');
        bubble.className = 'bubble ' + (msg.username === currentUser ? 'sent' : 'received');

        if(msg.type === 'text'){
            bubble.textContent = msg.content;
        } else if (msg.type === 'image'){
            const img = document.createElement('img');
            // msg.content expected to be full path like '/uploads/abc.jpg' or absolute url
            img.src = (msg.content.startsWith('http') ? msg.content : location.origin + msg.content);
            img.alt = 'Image';
            img.loading = 'lazy';
            bubble.appendChild(img);
        } else if (msg.type === 'audio'){
            const audio = document.createElement('audio');
            audio.controls = true;
            audio.src = (msg.content.startsWith('http') ? msg.content : location.origin + msg.content);
            bubble.appendChild(audio);
        }

        row.appendChild(bubble);
        return row;
    }

    // display message, with optional de-dup logic for local-temp entries
    function displayMessage(msg, { isNew = false, temp = false, sending = false } = {}) {
        // remove any local temp duplicates if server message arrives
        if(!temp){
            // find a temp node that matches username + content (best-effort)
            const children = Array.from(messagesEl.children);
            for(const child of children){
                const tn = child.dataset.tempUsername;
                const tc = child.dataset.tempContent;
                if(tn && tc && tn === msg.username && tc === msg.content){
                    child.remove(); // remove temporary local one
                }
            }
        }

        const node = createMessageNode(msg, { temp, sending });
        if(isNew) {
            // put at end and scroll into view smoothly
            messagesEl.appendChild(node);
            node.scrollIntoView({behavior:'smooth', block:'end'});
        } else {
            messagesEl.appendChild(node);
        }
        // small cleanup scroll
        setTimeout(() => scrollBottom(false), 60);
    }

    // fetch message history and render
    async function loadMessageHistory(){
        try {
            const res = await fetch(`${location.origin}/messages`);
            if(!res.ok) throw new Error('Failed to load');
            const msgs = await res.json();
            messagesEl.innerHTML = '';
            msgs.forEach(m => displayMessage(m, { isNew: false }));
            scrollBottom(false);
        } catch (e) {
            console.error('Error loading history:', e);
        }
    }

    // typing UI update
    function updateTypingUI(){
        if(currentlyTyping.size === 0){
            typingArea.style.display = 'none';
            typingText.textContent = '';
        } else {
            typingArea.style.display = 'flex';
            // show a small "X is typing" text (if more than one, show count)
            if(currentlyTyping.size === 1){
                typingText.textContent = Array.from(currentlyTyping)[0] + ' is typing';
            } else {
                typingText.textContent = `${currentlyTyping.size} people are typing`;
            }
        }
    }

    // WebSocket connect/reconnect
    let reconnectTimer = null;
    function connectWebSocket(){
        const wsUrl = location.origin.replace(/^http/, 'ws');
        ws = new WebSocket(wsUrl);

        ws.addEventListener('open', () => {
            console.log('WS connected');
            if(reconnectTimer){ clearTimeout(reconnectTimer); reconnectTimer = null; }
            // re-register username after connection
            if(currentUser){
                ws.send(JSON.stringify({ type:'registerUser', username: currentUser }));
            }
            // reload history to sync any missed messages
            loadMessageHistory();
        });

        ws.addEventListener('message', (ev) => {
            try {
                const data = JSON.parse(ev.data);
                // debug
                // console.log('WS IN', data);

                if(data.type === 'newChatMessage'){
                    // server shape: { type:'newChatMessage', id, username, timestamp, content, type? }
                    // unify shape: ensure data.type -> message.type is one of 'text'|'image'|'audio'
                    const msgType = (data.type === 'newChatMessage' && data.type) ? null : null;
                    // Our server used 'type' for both envelope and message type; but server built payload as {type:'newChatMessage', id, username, timestamp, type: 'text'|'image'|'audio', content }
                    // handle both shapes:
                    const message = {
                        id: data.id || data._id || null,
                        username: data.username,
                        timestamp: data.timestamp || data.time,
                        type: data.type === 'newChatMessage' && data.content && data.hasOwnProperty('type') ? data.type : data.type,
                        // The server included a field named 'type' both as envelope and message type; but previously you had server sending {type:'newChatMessage', ...newMessage}
                        // To be robust, check for 'text'/'image'/'audio' in payload
                        content: data.content ?? data.text ?? data.filePath ?? data.file
                    };

                    // If server's message.type field exists and equals 'text'/'image'/'audio', use it
                    if(data.messageType) message.type = data.messageType;
                    if(data.typeMessage) message.type = data.typeMessage;
                    // fallback: if payload includes property 'type' with value 'text', 'image', etc., use that
                    if(['text','image','audio'].includes(data.type)) message.type = data.type;

                    // dedupe any temporary local sending entries that match
                    displayMessage(message, { isNew: true });
                }

                else if(data.type === 'userTyping' || data.type === 'userStopTyping'){
                    const username = data.username;
                    if(data.type === 'userTyping'){
                        if(username !== currentUser) currentlyTyping.add(username);
                    } else {
                        currentlyTyping.delete(username);
                    }
                    updateTypingUI();
                }
            } catch (err){
                console.error('Failed to parse WS msg', err);
            }
        });

        ws.addEventListener('close', () => {
            console.log('WS closed — reconnecting in 2s');
            // try reconnecting
            if(reconnectTimer) clearTimeout(reconnectTimer);
            reconnectTimer = setTimeout(connectWebSocket, 2000);
        });

        ws.addEventListener('error', (err) => {
            console.error('WS error', err);
            ws?.close();
        });
    }

    // send text message (instant local render + send)
    function sendTextMessage(){
        const text = messageInput.value.trim();
        if(!text) return;
        // build a temp message
        const tempMsg = {
            id: 'temp-' + Date.now(),
            username: currentUser,
            timestamp: new Date().toISOString(),
            type: 'text',
            content: text
        };
        // show immediately as sending
        displayMessage(tempMsg, { isNew:true, temp:true, sending:true });

        // attempt to send
        if(ws && ws.readyState === WebSocket.OPEN){
            try {
                ws.send(JSON.stringify({ type:'chatMessage', username: currentUser, text }));
            } catch(e){
                console.error('Failed to send ws', e);
            }
        } else {
            // If ws not open, still POST to a backup endpoint? (optional) We will rely on reload/check.
            console.warn('WS not open: message queued on client only');
        }

        // stop typing
        clearTimeout(typingTimeout);
        if(ws && ws.readyState === WebSocket.OPEN){
            try { ws.send(JSON.stringify({ type:'stopTyping', username: currentUser })); } catch(e){}
        }

        messageInput.value = '';
    }

    // handle image upload: upload to /upload, then display the returned path instantly (server serves it)
    async function uploadImage(file){
        const fd = new FormData();
        fd.append('media', file);
        try {
            const res = await fetch(`${location.origin}/upload`, { method:'POST', body: fd });
            const json = await res.json();
            if(json.success && json.filePath){
                const msg = {
                    id: 'tempimg-' + Date.now(),
                    username: currentUser,
                    timestamp: new Date().toISOString(),
                    type: 'image',
                    content: json.filePath // begins with /uploads/...
                };
                // show immediately (no sending flag — we can show as normal)
                displayMessage(msg, { isNew:true });
                // send broadcast request to server via ws to save to history
                if(ws && ws.readyState === WebSocket.OPEN){
                    ws.send(JSON.stringify({ type:'imageMessage', username: currentUser, filePath: json.filePath }));
                }
            } else {
                console.error('Upload failed', json);
            }
        } catch(e){
            console.error('Image upload exception', e);
        }
    }

    // Events
    joinForm.addEventListener('submit', async (ev) => {
        ev.preventDefault();
        const name = usernameInput.value.trim();
        if(!name) return;
        try {
            const res = await fetch(`${location.origin}/register`, {
                method:'POST',
                headers:{'Content-Type':'application/json'},
                body: JSON.stringify({ username: name })
            });
            const json = await res.json();
            if(!res.ok){
                joinError.textContent = json?.message || 'Failed to register';
                setTimeout(()=> joinError.textContent = '', 3000);
                return;
            }
            currentUser = name;
            localStorage.setItem('chat_username', name);
            headerAvatar.textContent = name.charAt(0).toUpperCase();
            joinScreen.style.display = 'none';
            // load history and open ws
            loadMessageHistory();
            connectWebSocket();
        } catch(err){
            console.error('Register failed', err);
            joinError.textContent = 'Server error';
        }
    });

    // if user already set, skip join UI
    if(currentUser){
        usernameInput.value = currentUser;
        headerAvatar.textContent = currentUser.charAt(0).toUpperCase();
        joinScreen.style.display = 'none';
        loadMessageHistory();
        connectWebSocket();
    } else {
        joinScreen.style.display = '';
    }

    // send actions
    sendBtn.addEventListener('click', (e) => { e.preventDefault(); sendTextMessage(); });
    messageInput.addEventListener('keydown', (e) => {
        if(e.key === 'Enter' && !e.shiftKey){
            e.preventDefault();
            sendTextMessage();
        }
    });

    // typing events
    messageInput.addEventListener('input', () => {
        if(!ws || ws.readyState !== WebSocket.OPEN) return;
        try {
            ws.send(JSON.stringify({ type:'typing', username: currentUser }));
        } catch(e){}
        clearTimeout(typingTimeout);
        typingTimeout = setTimeout(() => {
            if(ws && ws.readyState === WebSocket.OPEN){
                try { ws.send(JSON.stringify({ type:'stopTyping', username: currentUser })); } catch(e){}
            }
        }, 1600);
    });

    // attach
    attachBtn.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', (ev) => {
        const file = ev.target.files?.[0];
        if(file) uploadImage(file);
        fileInput.value = '';
    });

    // allow clicking images to open bigger
    messagesEl.addEventListener('click', (ev) => {
        const img = ev.target.closest('img');
        if(img){
            // open in new tab
            window.open(img.src, '_blank');
        }
    });

    // If user toggles OS color scheme, browser will change automatically because we use prefers-color-scheme.
    // But if you want to perform additional JS-driven tweaks on change:
    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
        // (Pure CSS handles colors; we could animate or adjust icons here if necessary.)
    });

    // small accessibility: focus message input when typing or after join
    document.addEventListener('click', (e) => {
        if(e.target === document.body) messageInput.focus();
    });
});
</script>
</body>
</html>
